# Budget System Refactor Plan

**Created**: 2025-09-24
**Status**: Planning Phase
**Priority**: High

## Critical Issues Identified

#### 1. Critical Color Anti-Pattern üî• **URGENT**

**Location**: `apps/budget/src/routes/accounts/[id]/(components)/(cells)/data-table-editable-status-cell.svelte`

**Issue**: Hardcoded colors breaking design system and dark mode compatibility in status cell components.

#### 2. Form Pattern Duplication

**Issue**: 5+ form components repeat identical superForm setup patterns.

#### 3. Dialog Pattern Duplication

**Issue**: 4+ dialog components use identical ResponsiveSheet patterns.

#### 4. Entity State Opportunities

**Issue**: Similar CRUD patterns across entity state classes.

## Refactor Implementation Plan

### Phase 1: Critical Fixes üî• **IMMEDIATE** (1 day)

#### 1.1 Fix Color Anti-Pattern

**File**: `data-table-editable-status-cell.svelte`
**Action**: Replace all hardcoded colors with theme variables
**Estimated Time**: 30 minutes

```svelte
<!-- Replace with theme variables -->
<SquareCheck class="fill-primary text-primary-foreground hover:fill-primary/90" />
<Button class="hover:bg-accent hover:text-accent-foreground">
<Calendar class="text-primary hover:text-primary/80" />
```

#### 1.2 Remove Debug Console Statements

**Locations**: 15 files with `console.log/warn/error`
**Action**: Remove or replace with proper error handling
**Estimated Time**: 1 hour

**Priority Files**:

- `routes/budgets/+page.svelte`
- `routes/accounts/[id]/+page.svelte`
- `routes/transactions/+page.server.ts`

### Phase 2: High-Impact Abstractions (3-5 days)

#### 2.1 Create `useEntityForm()` Hook

**‚ö†Ô∏è CRITICAL PARAMETER MISSING**: The hook called `superForm(formData, ...)` but never accepted `formData` as parameter.

**Problem Analysis**:
```typescript
// Current form pattern from manage-account-form.svelte:22-45
const {
  data: {manageAccountForm}, // ‚Üê formData from page data
} = page;

const form = superForm(manageAccountForm, {
  id: 'account-form',
  validators: zod4Client(superformInsertAccountSchema),
  onResult: async ({result}) => {
    if (onSave && result.type === 'success' && result.data) {
      accounts.updateAccount(result.data['entity']); // ‚Üê State management
      onSave(result.data['entity']);
    }
  },
});

// Hook called superForm(formData, ...) but formData was undefined!
```

**CORRECTED APPROACH: Accept formData Parameter**

**Purpose**: Eliminate form setup duplication across 5+ components with proper formData handling
**Location**: `src/lib/hooks/forms/use-entity-form.ts`

```typescript
import { superForm, type SuperForm } from 'sveltekit-superforms/client';
import { zod4Client } from 'sveltekit-superforms/adapters';
import type { z } from 'zod';

export interface EntityFormOptions<T extends z.ZodTypeAny> {
  formData: any; // SuperForm initial data from page.data
  schema: T;
  formId: string;
  onSave?: (entity: z.infer<T>) => void;
  onUpdate?: (entity: z.infer<T>) => void;
  onDelete?: (id: number) => void;
  entityId?: number;
  customOptions?: any; // Additional SuperForm options
}

/**
 * Standardized entity form hook with proper formData handling
 */
export function useEntityForm<T extends z.ZodTypeAny>({
  formData,
  schema,
  formId,
  onSave,
  onUpdate,
  onDelete,
  entityId,
  customOptions = {}
}: EntityFormOptions<T>) {

  const form = superForm(formData, {
    id: formId,
    validators: zod4Client(schema),
    resetForm: true,
    delayMs: 300,
    onResult: async ({ result }) => {
      if (result.type === 'success' && result.data) {
        const entity = result.data['entity'];

        if (entity) {
          if (entityId && entityId > 0) {
            // Existing entity - update
            if (onUpdate) {
              onUpdate(entity);
            } else if (onSave) {
              onSave(entity); // Fallback to onSave
            }
          } else {
            // New entity - create
            if (onSave) {
              onSave(entity);
            }
          }
        }
      }
    },
    onError: ({ result }) => {
      console.error('Form submission error:', result.error);
    },
    ...customOptions
  });

  return form;
}

/**
 * Usage helper for common entity patterns
 */
export function createEntityFormConfig<T extends z.ZodTypeAny>(
  schema: T,
  entityName: string
) {
  return {
    schema,
    formId: `${entityName}-form`,
    customOptions: {
      resetForm: true,
      invalidateAll: true
    }
  };
}

/**
 * Example usage patterns for different entity types
 */
export const entityFormConfigs = {
  account: createEntityFormConfig(superformInsertAccountSchema, 'account'),
  transaction: createEntityFormConfig(superformInsertTransactionSchema, 'transaction'),
  schedule: createEntityFormConfig(superformInsertScheduleSchema, 'schedule'),
  // Add other entities as needed
};
```

**Usage Example**:
```typescript
// In component (e.g., manage-account-form.svelte)
<script lang="ts">
  import { useEntityForm, entityFormConfigs } from '$lib/hooks/forms/use-entity-form';
  import { page } from '$app/state';
  import { AccountsState } from '$lib/states/entities/accounts.svelte';

  let { accountId, onSave }: Props = $props();

  const accounts = AccountsState.get();

  // Get formData from page data (SvelteKit pattern)
  const { data: { manageAccountForm } } = page;

  // Use the standardized hook
  const form = useEntityForm({
    formData: manageAccountForm, // ‚úÖ Now properly passed
    ...entityFormConfigs.account, // ‚úÖ Includes schema, formId, and customOptions
    entityId: accountId,
    onSave: (account) => {
      accounts.addAccount(account);
      onSave?.(account);
    },
    onUpdate: (account) => {
      accounts.updateAccount(account);
      onSave?.(account);
    }
  });

  const { form: formData, enhance } = form;
</script>
```

**Key Fixes**: formData parameter, TypeScript compatibility, proper customOptions handling.

#### 2.2 Build `FormDialog` Component

**‚ö†Ô∏è CRITICAL BINDING AND PROPS ISSUES**: Component references undefined variables and lacks proper binding contract.

**Problems Identified**:
```svelte
<!-- ‚ùå Problems in original FormDialog -->
<script lang="ts">
interface Props {
  open: boolean;      // ‚Üê Not destructured from $props()
  title: string;      // ‚Üê Not destructured from $props()
  // ... other props
}
</script>

<ResponsiveSheet bind:open> <!-- ‚ùå open is not defined -->
  <h2>{title}</h2> <!-- ‚ùå title is not defined -->
  <Button onclick={onClose}> <!-- ‚ùå onClose is not defined -->
  <!-- Component would fail to compile -->
```

**CORRECTED APPROACH: Proper Props and Binding**

**Purpose**: Standardize dialog patterns across 4+ components with proper Svelte 5 patterns
**Location**: `src/lib/components/dialogs/form-dialog.svelte`

```svelte
<script lang="ts">
import ResponsiveSheet from '$lib/components/ui/responsive-sheet/responsive-sheet.svelte';
import { Button } from '$lib/components/ui/button';
import { enhance } from '$app/forms';
import type { Snippet } from 'svelte';
import type { SubmitFunction } from '@sveltejs/kit';

interface Props {
  open?: boolean;
  title: string;
  description?: string;
  isSubmitting?: boolean;
  submitText?: string;
  cancelText?: string;
  formAction?: string;
  method?: 'POST' | 'PUT' | 'DELETE';
  onSave?: () => void;
  onClose?: () => void;
  onOpenChange?: (open: boolean) => void;
  onResult?: (result: any) => void;
  children: Snippet;
  footer?: Snippet<[{ isSubmitting: boolean; onClose: () => void; onSave?: () => void }]>;
}

// ‚úÖ Properly destructure all props
let {
  open = $bindable(false), // ‚úÖ Bindable for two-way binding
  title,
  description,
  isSubmitting = false,
  submitText = 'Save',
  cancelText = 'Cancel',
  formAction,
  method = 'POST',
  onSave,
  onClose,
  onOpenChange,
  onResult,
  children,
  footer
}: Props = $props();

// Hold reference to form element for programmatic submission
let formElement: HTMLFormElement | null = $state(null);

// Handle form submission with SvelteKit enhance
const handleSubmit: SubmitFunction = ({ formElement, submitter, cancel }) => {
  if (isSubmitting) {
    cancel();
    return;
  }

  return async ({ result }) => {
    if (onResult) {
      onResult(result);
    }

    // Auto-close on successful submission
    if (result.type === 'success') {
      open = false;
    }
  };
};

function handleFormSave() {
  if (formAction && formElement) {
    // Trigger form submission programmatically for buttons outside form
    formElement.requestSubmit();
  } else if (onSave) {
    // Fallback for non-form dialogs
    onSave();
  }
}

function handleClose() {
  if (!isSubmitting) {
    open = false;
    if (onClose) {
      onClose();
    }
  }
}

// Handle open change events
function handleOpenChange(newOpen: boolean) {
  open = newOpen;
  if (onOpenChange) {
    onOpenChange(newOpen);
  }

  // Call onClose when dialog is closed
  if (!newOpen && onClose) {
    onClose();
  }
}
</script>

<!-- ‚úÖ Proper binding contract -->
<ResponsiveSheet bind:open onOpenChange={handleOpenChange}>
  {#snippet header()}
    <div class="flex flex-col space-y-1.5 text-left">
      <h2 class="text-lg font-semibold leading-none tracking-tight">{title}</h2>
      {#if description}
        <p class="text-sm text-muted-foreground">{description}</p>
      {/if}
    </div>
  {/snippet}

  <div class="flex-1 overflow-y-auto px-6">
    {#if formAction}
      <!-- SvelteKit form with proper enhance and ref for programmatic submission -->
      <form bind:this={formElement} {method} action={formAction} use:enhance={handleSubmit} class="space-y-4">
        {@render children()}

        <!-- Hidden submit button for form validation -->
        <button type="submit" class="sr-only" tabindex="-1" aria-hidden="true">Submit</button>
      </form>
    {:else}
      <!-- Non-form content -->
      <div class="space-y-4">
        {@render children()}
      </div>
    {/if}
  </div>

  {#snippet footer()}
    {#if footer}
      {@render footer({ isSubmitting, onClose: handleClose, onSave })}
    {:else}
      <div class="flex flex-col-reverse gap-2 sm:flex-row sm:justify-end">
        <Button
          variant="outline"
          onclick={handleClose}
          disabled={isSubmitting}
          class="sm:w-auto"
        >
          {cancelText}
        </Button>
        <Button
          onclick={handleFormSave}
          disabled={isSubmitting}
          type={formAction ? 'submit' : 'button'}
          class="sm:w-auto"
        >
          {#if isSubmitting}
            <div class="mr-2 h-4 w-4 animate-spin rounded-full border-2 border-current border-t-transparent"></div>
          {/if}
          {isSubmitting ? 'Saving...' : submitText}
        </Button>
      </div>
    {/if}
  {/snippet}
</ResponsiveSheet>
```

**Usage Example**:
```svelte
<script lang="ts">
  import FormDialog from '$lib/components/dialogs/form-dialog.svelte';
  import { ManageAccountForm } from '$lib/components/forms';

  let dialogOpen = $state(false);
  let isSubmitting = $state(false);

  function handleSave() {
    isSubmitting = true;
    // Form submission logic
  }

  function handleClose() {
    dialogOpen = false;
    // Reset form state
  }
</script>

<!-- ‚úÖ Proper binding usage -->
<FormDialog
  bind:open={dialogOpen}
  title="Add Account"
  description="Create a new account for tracking expenses"
  {isSubmitting}
  onSave={handleSave}
  onClose={handleClose}
  formAction="/accounts?/create"
>
  <ManageAccountForm />
</FormDialog>
```

**Key Fixes**: Props destructuring, $bindable() contract, formElement.requestSubmit() for external buttons.

#### 2.3 ~~Develop `BaseEntityState<T>` Class~~ **REVISED APPROACH**

**REVISED APPROACH: Composition over Inheritance**

Abstract base classes would break existing domain-specific functionality. Instead, create **optional utility mixins**:

**Location**: `src/lib/states/mixins/`

#### 2.3.1 Core Entity Store Mixin

**File**: `src/lib/states/mixins/entity-store-mixin.ts`

```typescript
import { SvelteMap } from "svelte/reactivity";

export interface EntityStoreMixin<T extends { id: number }> {
  entities: SvelteMap<number, T>;
  init(entities: T[]): void;
  get all(): T[];
  get count(): number;
  getById(id: number): T | undefined;
  findBy(predicate: (entity: T) => boolean): T | undefined;
  filterBy(predicate: (entity: T) => boolean): T[];
  add(entity: T): void;
  update(entity: T): void;
  remove(id: number): T | undefined;
  has(id: number): boolean;
  clear(): void;
}

/**
 * Creates entity store operations for a given SvelteMap instance
 * Usage: Create the SvelteMap with $state in the consuming class
 */
export function createEntityStore<T extends { id: number }>(
  entities: SvelteMap<number, T>
): EntityStoreMixin<T> {
  return {
    entities,

    init(newEntities: T[]) {
      entities.clear();
      newEntities.forEach(entity => entities.set(entity.id, entity));
    },

    get all(): T[] {
      return entities.values().toArray();
    },

    get count(): number {
      return entities.size;
    },

    getById(id: number): T | undefined {
      return entities.get(id);
    },

    findBy(predicate: (entity: T) => boolean): T | undefined {
      return entities.values().find(predicate);
    },

    filterBy(predicate: (entity: T) => boolean): T[] {
      return entities.values().filter(predicate).toArray();
    },

    add(entity: T) {
      entities.set(entity.id, entity);
    },

    update(entity: T) {
      entities.set(entity.id, entity);
    },

    remove(id: number): T | undefined {
      const entity = entities.get(id);
      if (entity) {
        entities.delete(id);
        return entity;
      }
      return undefined;
    },

    has(id: number): boolean {
      return entities.has(id);
    },

    clear(): void {
      entities.clear();
    }
  };
}
```

#### 2.3.2 Selection Management Mixin (Optional)

**File**: `src/lib/states/mixins/selection-mixin.ts`

```typescript
import { SvelteSet } from "svelte/reactivity";

export interface SelectionMixin<T extends { id: number }> {
  selectedIds: SvelteSet<number>;
  selectEntity(id: number): void;
  deselectEntity(id: number): void;
  toggleEntitySelection(id: number): void;
  selectAll(): void;
  deselectAll(): void;
  get selectedEntities(): T[];
}

/**
 * Creates selection management operations for a given SvelteSet instance
 * Usage: Create the SvelteSet with $state in the consuming class
 *
 * IMPORTANT: Must use SvelteSet, not plain Set, for reactivity in Svelte 5
 */
export function createSelectionMixin<T extends { id: number }>(
  selectedIds: SvelteSet<number>,
  getEntities: () => T[]
): SelectionMixin<T> {
  return {
    selectedIds,

    selectEntity(id: number): void {
      selectedIds.add(id); // SvelteSet.add() triggers reactivity
    },

    deselectEntity(id: number): void {
      selectedIds.delete(id); // SvelteSet.delete() triggers reactivity
    },

    toggleEntitySelection(id: number): void {
      if (selectedIds.has(id)) {
        selectedIds.delete(id); // SvelteSet mutation triggers updates
      } else {
        selectedIds.add(id);
      }
    },

    selectAll(): void {
      getEntities().forEach((entity: T) => selectedIds.add(entity.id));
    },

    deselectAll(): void {
      selectedIds.clear(); // SvelteSet.clear() triggers reactivity
    },

    get selectedEntities(): T[] {
      return getEntities().filter(entity => selectedIds.has(entity.id));
    }
  };
}

```

#### 2.3.3 Sort Persistence Mixin

**File**: `src/lib/states/mixins/sort-persistence-mixin.ts`

```typescript
export interface SortPersistenceMixin<TSortField, TSortDirection> {
  sortField: TSortField;
  sortDirection: TSortDirection;
  setSorting(field: TSortField, direction: TSortDirection): void;
  toggleSortDirection(): void;
  loadSortPreferences(): void;
  saveSortPreferences(): void;
}

/**
 * Creates sort persistence utilities with proper reactive state binding
 * Usage: Pass getter/setter functions that directly access reactive state
 */
export function createSortPersistence<TSortField, TSortDirection>(
  storageKey: string,
  getSortField: () => TSortField,
  setSortField: (value: TSortField) => void,
  getSortDirection: () => TSortDirection,
  setSortDirection: (value: TSortDirection) => void,
  isValidField: (field: any) => field is TSortField,
  isValidDirection: (direction: any) => direction is TSortDirection,
  getOppositeDirection: (current: TSortDirection) => TSortDirection
): SortPersistenceMixin<TSortField, TSortDirection> {

  const loadSortPreferences = () => {
    if (typeof window !== "undefined") {
      try {
        const saved = localStorage.getItem(storageKey);
        if (saved) {
          const { field, direction } = JSON.parse(saved);
          if (isValidField(field) && isValidDirection(direction)) {
            setSortField(field);
            setSortDirection(direction);
          }
        }
      } catch (error) {
        console.warn(`Failed to load ${storageKey}:`, error);
      }
    }
  };

  const saveSortPreferences = () => {
    if (typeof window !== "undefined") {
      try {
        const preferences = { field: getSortField(), direction: getSortDirection() };
        localStorage.setItem(storageKey, JSON.stringify(preferences));
      } catch (error) {
        console.warn(`Failed to save ${storageKey}:`, error);
      }
    }
  };

  return {
    get sortField() { return getSortField(); },
    set sortField(value: TSortField) { setSortField(value); },

    get sortDirection() { return getSortDirection(); },
    set sortDirection(value: TSortDirection) { setSortDirection(value); },

    setSorting(field: TSortField, direction: TSortDirection) {
      setSortField(field);
      setSortDirection(direction);
      saveSortPreferences();
    },

    toggleSortDirection() {
      setSortDirection(getOppositeDirection(getSortDirection()));
      saveSortPreferences();
    },

    loadSortPreferences,
    saveSortPreferences
  };
}

```

#### 2.3.4 Refactored AccountsState Implementation

**File**: `src/lib/states/entities/accounts.svelte.ts`

```typescript
import type { Account } from "$lib/schema";
import { trpc } from "$lib/trpc/client";
import { getContext, setContext } from "svelte";
import { SvelteMap } from "svelte/reactivity";

const KEY = Symbol("accounts");
export type AccountSortField = "name" | "balance" | "dateOpened" | "status" | "createdAt";
export type SortDirection = "asc" | "desc";

export class AccountsState {
  // Keep existing reactive state pattern (works in .svelte.ts files)
  accounts = $state(new SvelteMap<number, Account>()) as SvelteMap<number, Account>;
  sortField = $state<AccountSortField>("name");
  sortDirection = $state<SortDirection>("asc");

  constructor(accounts?: Account[]) {
    // Load persisted sort preferences
    this.loadSortPreferences();
    if (accounts) {
      this.init(accounts);
    }
  }

  // CRUD operations (could use mixin if desired, but keeping direct approach)
  init(accounts: Account[]) {
    this.accounts.clear();
    accounts.forEach((account) => this.accounts.set(account.id, account));
  }

  get all(): Account[] {
    return this.accounts.values().toArray();
  }

  get count(): number {
    return this.accounts.size;
  }

  getById(id: number): Account | undefined {
    return this.accounts.get(id);
  }

  findBy(predicate: (account: Account) => boolean): Account | undefined {
    return this.accounts.values().find(predicate);
  }

  filterBy(predicate: (account: Account) => boolean): Account[] {
    return this.accounts.values().filter(predicate).toArray();
  }

  addAccount(account: Account) {
    this.accounts.set(account.id, account);
  }

  updateAccount(account: Account) {
    this.accounts.set(account.id, account);
  }

  removeAccount(id: number): Account | undefined {
    const account = this.accounts.get(id);
    if (account) {
      this.accounts.delete(id);
      return account;
    }
    return undefined;
  }

  has(id: number): boolean {
    return this.accounts.has(id);
  }

  clear(): void {
    this.accounts.clear();
  }

  // Sorting methods with persistence
  setSorting(field: AccountSortField, direction: SortDirection) {
    this.sortField = field;
    this.sortDirection = direction;
    this.saveSortPreferences();
  }

  toggleSortDirection() {
    this.sortDirection = this.sortDirection === "asc" ? "desc" : "asc";
    this.saveSortPreferences();
  }

  // Sort preference persistence (could use mixin, but keeping direct approach)
  private loadSortPreferences() {
    if (typeof window !== "undefined") {
      try {
        const saved = localStorage.getItem("accounts-sort-preferences");
        if (saved) {
          const {field, direction} = JSON.parse(saved);
          if (this.isValidSortField(field) && this.isValidSortDirection(direction)) {
            this.sortField = field;
            this.sortDirection = direction;
          }
        }
      } catch (error) {
        console.warn("Failed to load sort preferences:", error);
      }
    }
  }

  private saveSortPreferences() {
    if (typeof window !== "undefined") {
      try {
        const preferences = {
          field: this.sortField,
          direction: this.sortDirection,
        };
        localStorage.setItem("accounts-sort-preferences", JSON.stringify(preferences));
      } catch (error) {
        console.warn("Failed to save sort preferences:", error);
      }
    }
  }

  private isValidSortField(field: any): field is AccountSortField {
    return ["name", "balance", "dateOpened", "status", "createdAt"].includes(field);
  }

  private isValidSortDirection(direction: any): direction is SortDirection {
    return ["asc", "desc"].includes(direction);
  }

  // Context management (keep original pattern)
  static get() {
    return getContext<AccountsState>(KEY);
  }

  static set(accounts: Account[]) {
    return setContext(KEY, new AccountsState(accounts));
  }

  // PRESERVE ALL existing domain-specific functionality
  sorted = $derived(this.sortAccounts(this.all, this.sortField, this.sortDirection));

  getByName(name: string): Account | undefined {
    return this.findBy((account) => account.name === name);
  }

  getActiveAccounts(): Account[] {
    return this.filterBy((account) => !account.closed);
  }

  getClosedAccounts(): Account[] {
    return this.filterBy((account) => !!account.closed);
  }

  getTotalBalance(): number {
    return this.all.reduce((total, account) => total + (account.balance || 0), 0);
  }

  // PRESERVE ALL existing tRPC integration
  async saveAccount(account: Account): Promise<Account> {
    const accountForMutation = {
      ...account,
      closed: account.closed ?? undefined,
    };
    const result = await trpc().accountRoutes.save.mutate(accountForMutation);
    const accountWithDefaults: Account = {
      ...result,
      transactions: [],
      balance: 0,
    };
    this.addAccount(accountWithDefaults);
    return accountWithDefaults;
  }

  async deleteAccount(id: number): Promise<void> {
    await trpc().accountRoutes.remove.mutate({id});
    this.removeAccount(id);
  }

  async deleteAccounts(ids: number[]): Promise<void> {
    await Promise.all(ids.map((id) => this.deleteAccount(id)));
  }

  // PRESERVE ALL existing sorting logic
  private sortAccounts(
    accounts: Account[],
    field: AccountSortField,
    direction: SortDirection
  ): Account[] {
    return [...accounts].sort((a, b) => {
      let aValue: any;
      let bValue: any;

      switch (field) {
        case "name":
          aValue = a.name?.toLowerCase() || "";
          bValue = b.name?.toLowerCase() || "";
          break;
        case "balance":
          aValue = a.balance || 0;
          bValue = b.balance || 0;
          break;
        case "dateOpened":
          aValue = a.dateOpened ? new Date(a.dateOpened).getTime() : 0;
          bValue = b.dateOpened ? new Date(b.dateOpened).getTime() : 0;
          break;
        case "status":
          aValue = a.closed ? 1 : 0;
          bValue = b.closed ? 1 : 0;
          break;
        case "createdAt":
          aValue = a.createdAt ? new Date(a.createdAt).getTime() : 0;
          bValue = b.createdAt ? new Date(b.createdAt).getTime() : 0;
          break;
        default:
          aValue = a.name?.toLowerCase() || "";
          bValue = b.name?.toLowerCase() || "";
      }

      if (aValue < bValue) return direction === "asc" ? -1 : 1;
      if (aValue > bValue) return direction === "asc" ? 1 : -1;
      return 0;
    });
  }

  getSortedActiveAccounts(): Account[] {
    return this.sortAccounts(this.getActiveAccounts(), this.sortField, this.sortDirection);
  }

  getSortedClosedAccounts(): Account[] {
    return this.sortAccounts(this.getClosedAccounts(), this.sortField, this.sortDirection);
  }
}
```

**Benefits**: Optional utilities for new code, preserves existing functionality, no breaking changes.

#### 2.4 Create Chart Configuration Utilities

**Purpose**: Standardize chart patterns across 5+ chart components
**Location**: `src/lib/utils/chart-config.ts`

```typescript
export function createChartConfig(configs: Array<{
  key: string;
  label: string;
  colorVar: string;
}>): ChartConfig {
  return configs.reduce((acc, {key, label, colorVar}) => ({
    ...acc,
    [key]: {
      label,
      color: `hsl(var(${colorVar}))`
    }
  }), {});
}

export const standardChartConfigs = {
  spending: createChartConfig([
    { key: 'spending', label: 'Spending', colorVar: '--chart-1' },
    { key: 'income', label: 'Income', colorVar: '--chart-2' }
  ]),
  // Additional standard configurations
};
```

### Phase 3: Data & Performance Optimization (2-3 days)

#### 3.1 Create `useMonthlyAggregation()` Hook

**‚ö†Ô∏è CRITICAL DATE HANDLING ISSUE IDENTIFIED**: The hook incorrectly assumed `date.year`/`date.month` properties.

**Problem Analysis**:
**CORRECTED APPROACH: Handle Mixed Date Formats**

**Purpose**: Eliminate repeated monthly data transformation logic with **proper DateValue conversion**
**Location**: `src/lib/hooks/data/use-monthly-aggregation.ts`

```typescript
import type { DateValue } from '@internationalized/date';
import { parseDateValue } from '$lib/utils/dates';
import type { TransactionsFormat } from '$lib/types/transactions';

/**
 * Monthly aggregation hook with explicit DateValue support
 *
 * CRITICAL: This hook assumes DateValue objects as used throughout the budget app.
 * All date fields must be DateValue or convertible to DateValue via parseDateValue().
 */
export function useMonthlyAggregation<T, R = number>(
  data: T[],
  dateField: keyof T,
  aggregationFn: (items: T[]) => R,
  options: {
    sortOrder?: 'asc' | 'desc';
    includeEmpty?: boolean;
  } = {}
) {
  const { sortOrder = 'asc', includeEmpty = false } = options;

  return $derived.by(() => {
    if (!data?.length) return [];

    const monthlyGroups = new Map<string, T[]>();

    // Group data by month handling multiple date formats
    data.forEach(item => {
      const rawDate = item[dateField];

      // Handle the reality of mixed date formats in the domain
      let monthKey: string;

      if (!rawDate) {
        console.warn('Missing date in monthly aggregation:', item);
        return;
      }

      try {
        if (rawDate && typeof rawDate === 'object' && 'year' in rawDate && 'month' in rawDate) {
          // DateValue object (UI layer, TransactionsFormat)
          const dateValue = rawDate as DateValue;
          monthKey = `${dateValue.year}-${String(dateValue.month).padStart(2, '0')}`;

        } else if (rawDate instanceof Date) {
          // Native Date object (domain models, widget calculations)
          const year = rawDate.getFullYear();
          const month = rawDate.getMonth() + 1; // JS months are 0-indexed
          monthKey = `${year}-${String(month).padStart(2, '0')}`;

        } else if (typeof rawDate === 'string') {
          // ISO string (database, API responses)
          const dateValue = parseDateValue(rawDate);
          if (dateValue) {
            monthKey = `${dateValue.year}-${String(dateValue.month).padStart(2, '0')}`;
          } else {
            // Fallback: try parsing as JS Date
            const jsDate = new Date(rawDate);
            if (!isNaN(jsDate.getTime())) {
              const year = jsDate.getFullYear();
              const month = jsDate.getMonth() + 1;
              monthKey = `${year}-${String(month).padStart(2, '0')}`;
            } else {
              throw new Error(`Could not parse date string: ${rawDate}`);
            }
          }

        } else {
          throw new Error(`Unsupported date format: ${typeof rawDate}`);
        }

        if (!monthlyGroups.has(monthKey)) {
          monthlyGroups.set(monthKey, []);
        }
        monthlyGroups.get(monthKey)!.push(item);

      } catch (error) {
        console.warn('Date processing error in monthly aggregation:', error, 'Raw date:', rawDate);
        return;
      }
    });

    // Convert to chart data format
    let result = Array.from(monthlyGroups.entries())
      .map(([monthKey, items]) => {
        const [year, month] = monthKey.split('-').map(Number);
        return {
          x: monthKey,
          y: aggregationFn(items),
          date: new Date(year, month - 1, 1), // LayerChart requires JS Date
          monthKey,
          count: items.length,
          items: includeEmpty ? items : undefined
        };
      });

    // Sort results
    result.sort((a, b) => {
      const comparison = a.x.localeCompare(b.x);
      return sortOrder === 'asc' ? comparison : -comparison;
    });

    return result;
  });
}

/**
 * Specialized hook for TransactionsFormat (guaranteed DateValue)
 */
export function useTransactionMonthlyAggregation(
  transactions: TransactionsFormat[],
  type: 'sum' | 'average' | 'count' = 'sum'
) {
  return useMonthlyAggregation(
    transactions,
    'date', // TransactionsFormat.date is guaranteed to be DateValue
    (items) => {
      switch (type) {
        case 'sum':
          return items.reduce((sum, tx) => sum + (tx.amount || 0), 0);
        case 'average':
          const total = items.reduce((sum, tx) => sum + (tx.amount || 0), 0);
          return items.length > 0 ? total / items.length : 0;
        case 'count':
          return items.length;
        default:
          return 0;
      }
    }
  );
}
```

**Key Fixes Applied**:

- ‚úÖ **Explicit DateValue handling**: Properly checks for DateValue properties
- ‚úÖ **Type safety**: Uses `TransactionsFormat` type for transaction-specific hooks
- ‚úÖ **Error handling**: Warns about invalid date formats instead of throwing
- ‚úÖ **LayerChart compatibility**: Converts DateValue ‚Üí JS Date for chart rendering
- ‚úÖ **Follows existing patterns**: Matches how charts currently handle DateValue objects

**This matches existing working code**:

```typescript
// From income-vs-expenses-chart.svelte:25
const monthKey = `${transaction.date.year}-${String(transaction.date.month).padStart(2, '0')}`;
// transaction.date is DateValue, so .year/.month work correctly
```

#### 3.2 Fix TypeScript `any` Usage

**Locations**: 10+ locations using `any` type
**Action**: Replace with proper typing

**Priority Fixes**:

```typescript
// Current problematic code
const updateData: any = {};

// Replace with proper types
interface UpdateTransactionData {
  amount?: number;
  notes?: string;
  categoryId?: number;
  // ... other fields
}
const updateData: Partial<UpdateTransactionData> = {};
```

#### 3.3 Optimize Chart Data Processing

**Issue**: Multiple chart components perform similar data transformations
**Solution**: Create memoized chart data processors

```typescript
export function createMemoizedChartProcessor<T, R>(
  processFn: (data: T[]) => R
) {
  let lastData: T[] | undefined;
  let lastResult: R;

  return (data: T[]): R => {
    if (data === lastData) {
      return lastResult;
    }

    lastData = data;
    lastResult = processFn(data);
    return lastResult;
  };
}
```

### Phase 4: Quality of Life Improvements (1-2 days)

#### 4.1 Create `QueryStateWrapper` Component

**Purpose**: Simplify loading/error state handling across components

```svelte
<script lang="ts">
interface Props<T> {
  query: CreateQueryResult<T>;
  children: Snippet<[T]>;
  loadingContent?: Snippet;
  errorContent?: Snippet<[string]>;
}

let { query, children, loadingContent, errorContent }: Props<T> = $props();
</script>

{#if $query.isLoading}
  {#if loadingContent}
    {@render loadingContent()}
  {:else}
    <LoadingSpinner />
  {/if}
{:else if $query.error}
  {#if errorContent}
    {@render errorContent($query.error.message)}
  {:else}
    <ErrorMessage message={$query.error.message} />
  {/if}
{:else if $query.data}
  {@render children($query.data)}
{/if}
```

#### 4.2 Standardize Button Patterns

**Issue**: Inconsistent button placement and icon usage across pages
**Action**: Create `PageHeader` component following schedules page pattern

#### 4.3 Create Reusable Skeleton Components

**Purpose**: Consistent loading states across all data tables and cards
**Location**: `src/lib/components/ui/skeletons/`

### Phase 5: Advanced Abstractions (2-3 days)

#### 5.1 Build tRPC Route Factories

**Purpose**: Reduce CRUD endpoint duplication across 6+ route files

```typescript
export function createCrudRoutes<T, CreateInput, UpdateInput>(config: {
  entityName: string;
  service: {
    create: (data: CreateInput) => Promise<T>;
    update: (id: number, data: UpdateInput) => Promise<T>;
    delete: (id: number) => Promise<void>;
    findMany: () => Promise<T[]>;
    findById: (id: number) => Promise<T | null>;
  };
  schemas: {
    create: z.ZodSchema<CreateInput>;
    update: z.ZodSchema<UpdateInput>;
    remove: z.ZodSchema<{ id: number }>;
  };
}) {
  return t.router({
    create: rateLimitedProcedure
      .input(config.schemas.create)
      .mutation(async ({ input }) => config.service.create(input)),

    update: rateLimitedProcedure
      .input(config.schemas.update)
      .mutation(async ({ input: { id, ...data } }) =>
        config.service.update(id, data)),

    remove: rateLimitedProcedure
      .input(config.schemas.remove)
      .mutation(async ({ input }) => config.service.delete(input.id)),

    list: procedure
      .query(() => config.service.findMany()),

    byId: procedure
      .input(z.object({ id: z.number() }))
      .query(({ input }) => config.service.findById(input.id)),
  });
}
```

## Success Metrics

### Concrete Success Metrics

#### Quantitative Measurements

```bash
# Bundle Size Analysis
bun run build && bun run analyze-bundle
# Target: 15-25% reduction in component bundle size
# Baseline: Measure current component bundle sizes
# Post-refactor: Compare identical measurements

# Performance Benchmarks
bun run perf-test:charts
# Target: 30% reduction in chart rendering time
# Metrics: Time to first render, data processing time, memory usage

# Code Duplication Analysis
bun run analyze-duplication
# Target: 50% reduction in duplicated form/dialog patterns
# Metrics: Lines of repeated code, pattern instances
```

#### Developer Experience Metrics

```typescript
// Time-to-implement new component measurements
interface DevMetrics {
  beforeRefactor: {
    newFormComponent: '45 minutes',
    newDialogComponent: '30 minutes',
    newEntityState: '60 minutes'
  };
  afterRefactor: {
    newFormComponent: '15 minutes', // 67% reduction
    newDialogComponent: '10 minutes', // 67% reduction
    newEntityState: '20 minutes'     // 67% reduction
  };
}
```

#### Quality Gates

- **Type Safety**: Zero `any` types in core components
- **Design System**: 100% theme variable compliance
- **Performance**: No regression in chart rendering times
- **Test Coverage**: Maintain existing coverage levels
- **Bundle Size**: <1MB increase despite new abstractions

### Code Quality Improvements

- **Bundle Size**: 15-25% reduction in component code duplication
- **Type Safety**: Eliminate all `any` type usage in core components
- **Performance**: 30%+ reduction in redundant data processing
- **Maintainability**: Single source of truth for common patterns

### Developer Experience

- **Reduced Boilerplate**: 50%+ reduction in form and dialog setup code
- **Consistency**: Unified patterns across all similar components
- **Error Prevention**: Compile-time errors for pattern violations
- **Documentation**: Clear examples of abstracted patterns

### Technical Debt Reduction

- **Design System Compliance**: 100% theme variable usage
- **Console Cleanup**: Remove all debug statements from production code
- **Error Handling**: Consistent error boundaries and user feedback
- **State Management**: Centralized entity state patterns

## Risk Assessment

### Low Risk ‚úÖ

- **Color theme fixes**: Simple find-and-replace operations
- **Console statement removal**: Non-breaking cosmetic changes
- **Hook creation**: Additive changes that don't break existing code
- **Entity form hook**: Actually additive since it's a new utility
- **Monthly aggregation changes**: Low risk with proper testing
- **State management mixins**: **REVISED**: Now composable utilities instead of inheritance

### Medium Risk ‚ö†Ô∏è

- **Dialog component refactoring**: Changes component interfaces
- **LayerChart integration**: SVG compatibility requires specialist knowledge
- **Backward compatibility**: Need to maintain old patterns during migration
- **Chart data processing migration**: Could impact chart accuracy without proper validation

### High Risk üî¥

- **tRPC route factories**: Changes API endpoint structure
- **~~BaseEntityState inheritance~~**: **REMOVED** - was breaking existing domain logic

## Implementation Timeline

### Week 1: Foundation

- **Day 1**: Critical fixes (colors, console statements)
- **Day 2-3**: Entity form hook and dialog component
- **Day 4-5**: Base entity state class

### Week 2: Data & Performance

- **Day 1-2**: Monthly aggregation hook and chart utilities
- **Day 3**: TypeScript `any` fixes
- **Day 4-5**: Chart data processing optimization

### Week 3: Quality & Polish

- **Day 1-2**: Query state wrapper and button standardization
- **Day 3-5**: Skeleton components and advanced abstractions

## Validation Strategy

### Phase-by-Phase Testing

1. **Unit Tests**: Test each abstraction in isolation
2. **Integration Tests**: Verify existing functionality remains intact
3. **Visual Regression**: Ensure UI consistency is maintained
4. **Performance Testing**: Validate optimization improvements
5. **User Acceptance**: Confirm developer experience improvements

### Rollback Plan

- **Git Branches**: Each phase implemented in separate feature branches
- **Incremental Merging**: Merge and test each phase independently
- **Feature Flags**: Gradual rollout of new abstractions
- **Backup Strategy**: Maintain working versions at each milestone

## Post-Refactor Benefits

### Immediate Benefits

- **Design System Compliance**: Professional, consistent dark mode support
- **Cleaner Codebase**: Removal of debug statements and type issues
- **Reduced Duplication**: Significant reduction in repetitive code patterns

### Long-term Benefits

- **Faster Development**: Reusable patterns accelerate feature development
- **Easier Maintenance**: Centralized logic reduces maintenance overhead
- **Better Onboarding**: Clear patterns help new developers understand the codebase
- **Scalability**: Abstractions support growth without proportional complexity increase

### Architectural Evolution

- **Pattern Library**: Established abstractions become reusable pattern library
- **Documentation**: Living examples of best practices within the codebase
- **Quality Gates**: TypeScript and pattern enforcement prevent regression
- **Developer Confidence**: Well-tested abstractions enable fearless refactoring

## Conclusion

This refactor plan addresses critical technical debt while preserving the application's architectural strengths. The phased approach minimizes risk while delivering immediate improvements in code quality, developer experience, and system maintainability.

The budget system demonstrates sophisticated software engineering practices, and these refactoring efforts will enhance those strengths while eliminating the identified pain points. Priority should be given to the critical color anti-pattern fix and console statement cleanup, followed by the high-impact form and dialog abstractions that will provide immediate developer productivity benefits.

Success of this refactor will establish the budget application as an exemplary SvelteKit codebase with enterprise-grade patterns and maintainability.

---

**Next Steps**: Begin with Phase 1 critical fixes, then proceed incrementally through each phase with thorough testing and validation at each milestone.
